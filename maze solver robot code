
//  PIN DEFINITIONS

const int leftButtonPin  = 7;
const int rightButtonPin = 5;
const int photodiodePin  = A2;      // front “distance” sensor

// Motor-driver (forward/backward) pins
const int DIRA  = 12;
const int PWMA  = 3;
const int DIRB  = 13;
const int PWMB  = 11;
const int BrakeA = 9;
const int BrakeB = 8;

const int pinMotorLEFT  = 2;
const int pinMotorRIGHT = 4;
     // makes robot turn right


//  CONSTANTS & GLOBALS

const int   voltageThreshold = 770;   // wall-detect level
const int   tooCloseValue    = 970;   // “back-up” level
const int   fwdSpeed         = 37;   // 0-255 PWM
unsigned long noLightTime    = 0;
bool  gapDetected            = false;

// Remember what we were doing (so we can resume after backing up)
enum MoveState { FORWARD, TURN_LEFT, TURN_RIGHT };
MoveState lastMove = FORWARD;


//  SETUP

void setup() {
  pinMode(leftButtonPin,  INPUT);
  pinMode(rightButtonPin, INPUT);
  pinMode(photodiodePin,  INPUT);

  pinMode(DIRA, OUTPUT);
  pinMode(DIRB, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);

  pinMode(pinMotorLEFT,  OUTPUT);
  pinMode(pinMotorRIGHT, OUTPUT);
}


//  MAIN LOOP

void loop() {

  
  moveForward(fwdSpeed);           // start driving
  lastMove   = FORWARD;
  gapDetected = false;
  while (analogRead(photodiodePin) <= voltageThreshold) {
    // keep driving until wall is close
  }
  stopForward();                   // halt drive motors

  
  moveLeft();
  lastMove = TURN_LEFT;

  
  while (true) {

    int photoVal = analogRead(photodiodePin);

    // 3-A  Gap detection  (>1 s of "no wall")
    if (photoVal < voltageThreshold) {
      if (!gapDetected) {
        if (noLightTime == 0) {
          noLightTime = millis();              // first time “open”
        } else if (millis() - noLightTime > 500) {
          gapDetected = true;                  // 1 s gap found
          stopSideways();                      // stop turning
          break;                               // restart main loop
        }
      }
    }
    // 3-B  Too-close protection  (back up, then resume)
    else if (photoVal > tooCloseValue) {

      // remember what we were doing before backing up
      MoveState preBackupMove = lastMove;

      // full stop, then back up
      stopSideways();
      stopForward();
      moveBackward(fwdSpeed);
      delay(50);
      stopForward();

      // resume the same action as before
      if (preBackupMove == FORWARD) {
        moveForward(fwdSpeed);
        lastMove = FORWARD;
      } else if (preBackupMove == TURN_LEFT) {
        moveLeft();
        lastMove = TURN_LEFT;
      } else {                     // TURN_RIGHT (manual override case)
        moveRight();
        lastMove = TURN_RIGHT;
      }
      // loop continues…
    }
    // 3-C  Wall returned → reset gap timer
    else {
      noLightTime = 0;
    }

    // 3-D  Manual override buttons
    if (digitalRead(leftButtonPin) == HIGH) {   // LEFT button → turn RIGHT
      moveRight();
      lastMove = TURN_RIGHT;
    } else if (digitalRead(rightButtonPin) == HIGH) { // RIGHT button → turn LEFT
      moveLeft();
      lastMove = TURN_LEFT;
    }
  }
}


//  MOTOR CONTROL HELPERS


// Stop forward/backward motors (drive wheels only)
void stopForward() {
  analogWrite(PWMA, 0);
  analogWrite(PWMB, 0);
}

// Stop sideways motors (turning wheels only)
void stopSideways() {
  digitalWrite(pinMotorLEFT,  LOW);
  digitalWrite(pinMotorRIGHT, LOW);
}

// Drive straight forward at “speed”  (0–255)
void moveForward(int speed) {
  stopSideways();                // ensure no turning motors on
  digitalWrite(DIRA, HIGH);
  digitalWrite(DIRB, HIGH);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
}

// Drive straight backward
void moveBackward(int speed) {
  stopSideways();
  digitalWrite(DIRA, LOW);
  digitalWrite(DIRB, LOW);
  analogWrite(PWMA, speed);
  analogWrite(PWMB, speed);
}

// Rotate left on the spot
void moveLeft() {
  stopForward();
  digitalWrite(pinMotorLEFT,  HIGH);
  digitalWrite(pinMotorRIGHT, LOW);
}

// Rotate right on the spot
void moveRight() {
  stopForward();
  digitalWrite(pinMotorLEFT,  LOW);
  digitalWrite(pinMotorRIGHT, HIGH);
}
